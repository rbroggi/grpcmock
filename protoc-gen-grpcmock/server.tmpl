// Code generated by protoc-gen-grpcmock. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net"
	"os" 
	"errors"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto"
	"google.golang.org/grpc/status"

	"github.com/rbroggi/grpcmock/protoc-gen-grpcmock/runtime"
)

{{range .Services}}
// {{.MockServerStructName}} is the mock server for the {{.OriginalGoName}} service.
type {{.MockServerStructName}} struct {
	{{.QualifiedUnimplementedServerType}} 
}

// New{{.MockServerStructName}} creates a new mock server.
func New{{.MockServerStructName}}() *{{.MockServerStructName}} {
	return &{{.MockServerStructName}}{}
}

{{$service := .}} 
{{range .Methods}} 
// Method {{.GoName}} on mock server {{$service.MockServerStructName}} for gRPC service {{$service.OriginalGoName}}
func (s *{{$service.MockServerStructName}}) {{.GoName}}(
	{{if .ClientStreaming}}
	stream {{.QualifiedStreamServerType}},
	{{else if .ServerStreaming}}
	req *{{.InputType}}, stream {{.QualifiedStreamServerType}},
	{{else}} // Unary
	ctx context.Context, req *{{.InputType}},
	{{end}}
) {{if .ServerStreaming}} (error) {{else if .ClientStreaming}} (error) {{else}} (*{{.OutputType}}, error) {{end}} {
	
	fullMethod := "{{.FullMethodName}}"
	log.Printf("grpcmock: Received call to %s (mock server type: %s)", fullMethod, "{{$service.MockServerStructName}}")

	var currentReqProto proto.Message
	var incomingMD metadata.MD
	var err error 
	
	{{if .ClientStreaming}}
	firstReqProto, errRecv := stream.Recv()
	if errRecv == io.EOF {
		log.Printf("grpcmock: Client stream for %s ended before any message for matching.", fullMethod)
		currentReqProto = nil 
	} else if errRecv != nil {
		log.Printf("grpcmock: Error receiving from client stream for %s: %v", fullMethod, errRecv)
		return status.Errorf(codes.Internal, "error receiving from client stream: %v", errRecv)
	} else {
		currentReqProto = firstReqProto
	}
	incomingMD, _ = metadata.FromIncomingContext(stream.Context())
	{{else if .ServerStreaming}}
	currentReqProto = req 
	incomingMD, _ = metadata.FromIncomingContext(stream.Context())
	{{else}} // Unary
	currentReqProto = req
	incomingMD, _ = metadata.FromIncomingContext(ctx)
	{{end}}

	runtime.RecordCall(fullMethod, incomingMD, currentReqProto)
	
	expectation := runtime.FindMatchingExpectation(fullMethod, incomingMD, currentReqProto)

	if expectation == nil {
		err = status.Errorf(codes.Unimplemented, "no matching expectation for %s", fullMethod)
		{{if or .ServerStreaming .ClientStreaming}} return err {{else}} return nil, err {{end}}
	}

	if len(expectation.Response.Headers) > 0 {
		outgoingMD := metadata.New(expectation.Response.Headers)
		var headerErr error
		{{if .ClientStreaming}}
		headerErr = stream.SetHeader(outgoingMD)
		{{else if .ServerStreaming}}
		headerErr = stream.SendHeader(outgoingMD)
		{{else}} // Unary
		headerErr = grpc.SetHeader(ctx, outgoingMD)
		{{end}}
		if headerErr != nil {
			log.Printf("grpcmock: failed to set/send response header for %s: %v", fullMethod, headerErr)
			{{if or .ClientStreaming .ServerStreaming}} if headerErr != nil { return headerErr } {{end}}
		}
	}
	
	if expectation.Response.Error != nil {
		log.Printf("grpcmock: Returning error for %s: code=%v, msg=%s", fullMethod, expectation.Response.Error.Code, expectation.Response.Error.Message)
		err = status.Errorf(expectation.Response.Error.Code, expectation.Response.Error.Message)
		{{if or .ServerStreaming .ClientStreaming}} return err {{else}} return nil, err {{end}}
	}

	{{if .ServerStreaming}}
		resp := new({{.OutputType}}) 
		if errUnmarshal := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp); errUnmarshal != nil { 
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, errUnmarshal)
			return status.Errorf(codes.Internal, "failed to unmarshal mock server stream response: %v", errUnmarshal)
		}
		if errSend := stream.Send(resp); errSend != nil {
			log.Printf("grpcmock: Error sending server stream response for %s: %v", fullMethod, errSend)
			return errSend
		}
		return nil 
	{{else if .ClientStreaming}}
		for {
			if currentReqProto == nil && firstReqProto == nil { 
                break
            }
			_, errLoop := stream.Recv() 
			if errLoop == io.EOF { break }
			if errLoop != nil {
				log.Printf("grpcmock: Error receiving subsequent message from client stream for %s: %v", fullMethod, errLoop)
				return status.Errorf(codes.Internal, "error in client stream: %v", errLoop)
			}
		}
		resp := new({{.OutputType}})
		if errUnmarshal := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp); errUnmarshal != nil {
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, errUnmarshal)
			return status.Errorf(codes.Internal, "failed to unmarshal mock client stream response: %v", errUnmarshal)
		}
		return stream.SendAndClose(resp)
	{{else}} // Unary
		resp := new({{.OutputType}}) 
		if errUnmarshal := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp); errUnmarshal != nil {
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, errUnmarshal)
			return nil, status.Errorf(codes.Internal, "failed to unmarshal mock unary response: %v", errUnmarshal)
		}
		return resp, nil
	{{end}}
}
{{end}} {{/* End range Methods */}}
{{end}} {{/* End range Services */}}

func StartMockServer(grpcPort, httpPort string) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%s", grpcPort))
	if err != nil {
		log.Fatalf("grpcmock: failed to listen on gRPC port %s: %v", grpcPort, err)
	}
	
	grpcServer := grpc.NewServer()
	
	{{range .Services}}
	// Use QualifiedRegisterServerFuncName (based on OriginalGoName) and NewMockServerStructName
	{{.QualifiedRegisterServerFuncName}}(grpcServer, New{{.MockServerStructName}}())
	{{end}}
	
	log.Printf("grpcmock: gRPC server starting on :%s", grpcPort)
	go func() {
		if serveErr := grpcServer.Serve(lis); serveErr != nil && !errors.Is(serveErr, grpc.ErrServerStopped) {
			log.Fatalf("grpcmock: failed to serve gRPC: %v", serveErr)
		}
	}()

	_, httpShutdown := runtime.StartHTTPServer(httpPort, nil)

	log.Println("grpcmock: Servers started. Press Ctrl+C to exit.")
	runtime.ListenForShutdownSignal(func() {
		log.Println("grpcmock: shutting down gRPC server...")
		grpcServer.GracefulStop()
		log.Println("grpcmock: gRPC server stopped.")
	}, httpShutdown) 
	log.Println("grpcmock: All servers shut down.")
}

func main() {
	var grpcPort, httpPort string 

	defaultGrpcPort := "{{.GRPCPort}}"
	defaultHttpPort := "{{.HTTPPort}}"

	envGRPCPort := os.Getenv("GRPCMOCK_GRPC_PORT")
	if envGRPCPort != "" {
 		defaultGrpcPort = envGRPCPort
	}
	envHTTPPort := os.Getenv("GRPCMOCK_HTTP_PORT")
	if envHTTPPort != "" {
		defaultHttpPort = envHTTPPort
	}

	flag.StringVar(&grpcPort, "grpc-port", defaultGrpcPort, "gRPC server port for the mock")
	flag.StringVar(&httpPort, "http-port", defaultHttpPort, "HTTP control server port for the mock")
	flag.Parse()

	StartMockServer(grpcPort, httpPort)
}
