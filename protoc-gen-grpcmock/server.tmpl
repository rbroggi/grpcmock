// Code generated by protoc-gen-grpcmock. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"log"
	"fmt"
	"net"
	"io" // Required for streaming

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto" // For proto.Message
	"google.golang.org/protobuf/runtime/protoiface" // For protoiface.MessageV1

	// Import the grpcmock runtime
	// Ensure PluginModulePath is correctly set in your generator to your plugin's go module path
	"{{.PluginModulePath}}/protoc-gen-grpcmock/runtime"

	// Dynamic imports for user's proto message types
	{{range $alias, $path := .Imports}}
	{{$alias}} "{{$path}}"
	{{end}}
)

{{range .Services}}
// {{.GoName}}MockServer is the mock server for the {{.GoName}} service.
type {{.GoName}}MockServer struct {
	// Embed the Unimplemented server for forward compatibility
	{{$firstMethod := index .Methods 0}}
	{{/* Resolve the package alias for the UnimplementedServer struct */}}
	{{.GoPackageNameToken}}.Unimplemented{{.GoName}}Server
}

// New{{.GoName}}MockServer creates a new mock server.
func New{{.GoName}}MockServer() *{{.GoName}}MockServer {
	return &{{.GoName}}MockServer{}
}

{{$service := .}} {{/* Capture the current ServiceData context into $service */}}
{{range .Methods}} {{/* Current context (.) is MethodData */}}
func (s *{{$service.GoName}}MockServer) {{.GoName}}(
	{{if .ClientStreaming}}{{/* For client streaming, the first arg is the stream */}}
	stream {{$.GoPackageNameToken}}.{{$.GoName}}_{{.GoName}}Server
	{{else if .ServerStreaming}} {{/* Server streaming has request and stream */}}
	req *{{.InputType | BaseType}}, stream {{$.GoPackageNameToken}}.{{.GoName}}_{{.GoName}}Server
	{{else}}
	ctx context.Context, req *{{.InputType | BaseType}},
	{{end}}
){{if .ServerStreaming}} (error) {{else if .ClientStreaming}} (error) {{else}} (*{{.OutputType | BaseType}}, error) {{end}} {

	fullMethod := "{{.FullMethodName}}"
	log.Printf("grpcmock: Received call to %s", fullMethod)

	var currentReqProto proto.Message
	var incomingMD metadata.MD
	var err error

	{{if .ClientStreaming}}
	// Client Streaming: match based on the first message.
	// The runtime can be extended to handle expectations on the entire stream.
	firstReq, err := stream.Recv()
	if err == io.EOF {
		// Client closed stream without sending any message.
		// This could be a valid case for an expectation.
		log.Printf("grpcmock: Client stream ended for %s before any message for matching.", fullMethod)
	} else if err != nil {
		log.Printf("grpcmock: Error receiving from client stream for %s: %v", fullMethod, err)
		return status.Errorf(codes.Internal, "error receiving from client stream: %v", err)
	}
	currentReqProto = firstReq
	incomingMD, _ = metadata.FromIncomingContext(stream.Context())
	{{else if .ServerStreaming}}
	currentReqProto = req // req is the request object for server streaming
	incomingMD, _ = metadata.FromIncomingContext(stream.Context()) // stream is the server-side stream object
	{{else}} // Unary
	currentReqProto = req
	incomingMD, _ = metadata.FromIncomingContext(ctx)
	{{end}}

	runtime.RecordCall(fullMethod, incomingMD, currentReqProto)

	expectation := runtime.FindMatchingExpectation(fullMethod, incomingMD, currentReqProto)

	if expectation == nil {
		return {{if or .ServerStreaming .ClientStreaming}}{{else}}nil,{{end}} status.Errorf(codes.Unimplemented, "no matching expectation for %s", fullMethod)
	}

	// Handle response headers
	if len(expectation.Response.Headers) > 0 {
		outgoingMD := metadata.New(expectation.Response.Headers)
		{{if .ClientStreaming}}
		if err := stream.SetHeader(outgoingMD); err != nil {
			log.Printf("grpcmock: failed to set response header for %s: %v", fullMethod, err)
		}
		{{else if .ServerStreaming}}
		if err := stream.SendHeader(outgoingMD); err != nil {
			log.Printf("grpcmock: failed to send response header for %s: %v", fullMethod, err)
			return err // Important to return error if headers can't be sent
		}
		{{else}} // Unary
		if err := grpc.SetHeader(ctx, outgoingMD); err != nil {
			log.Printf("grpcmock: failed to set response header for %s: %v", fullMethod, err)
			// For unary, this error might not be directly returnable if SetHeader fails before main logic.
		}
		{{end}}
	}

	// Handle error response
	if expectation.Response.Error != nil {
		log.Printf("grpcmock: Returning error for %s: code=%v, msg=%s", fullMethod, expectation.Response.Error.Code, expectation.Response.Error.Message)
		return {{if or .ServerStreaming .ClientStreaming}}{{else}}nil,{{end}} status.Errorf(expectation.Response.Error.Code, expectation.Response.Error.Message)
	}

	// Handle data response
	{{if .ServerStreaming}}
		// Server streaming: send the mocked response(s)
		// This example sends one response. Extend for multiple/streamed responses.
		resp := &{{.OutputType | BaseType}}{}
		if err := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp.(protoiface.MessageV1)); err != nil {
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, err)
			return status.Errorf(codes.Internal, "failed to unmarshal mock server stream response: %v", err)
		}
		if err := stream.Send(resp); err != nil {
			log.Printf("grpcmock: Error sending server stream response for %s: %v", fullMethod, err)
			return err
		}
		return nil // Success for server streaming
	{{else if .ClientStreaming}}
		// Client streaming: consume the rest of the client's messages (if any)
		// The current matching logic is based on the *first* message.
		for {
			// Subsequent messages are just consumed here.
			// Extend if expectations need to react to the full stream.
			_, errLoop := stream.Recv()
			if errLoop == io.EOF {
				break // Client finished sending
			}
			if errLoop != nil {
				log.Printf("grpcmock: Error receiving subsequent message from client stream for %s: %v", fullMethod, errLoop)
				return status.Errorf(codes.Internal, "error in client stream: %v", errLoop)
			}
		}
		// Then, send the single response.
		resp := &{{.OutputType | BaseType}}{}
		if err := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp.(protoiface.MessageV1)); err != nil {
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, err)
			return status.Errorf(codes.Internal, "failed to unmarshal mock client stream response: %v", err)
		}
		return stream.SendAndClose(resp)
	{{else}} // Unary or Bi-directional (Bi-di would need extensive changes here)
		resp := &{{.OutputType | BaseType}}{}
		if err := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp.(protoiface.MessageV1)); err != nil {
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, err)
			return nil, status.Errorf(codes.Internal, "failed to unmarshal mock unary response: %v", err)
		}
		return resp, nil
	{{end}}
}
{{end}}
{{end}}

// StartMockServer initializes and starts the gRPC mock server and the HTTP control server.
// It blocks until a shutdown signal is received.
func StartMockServer(grpcPort, httpPort string) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%s", grpcPort))
	if err != nil {
		log.Fatalf("grpcmock: failed to listen on gRPC port %s: %v", grpcPort, err)
	}

	grpcServer := grpc.NewServer()

	{{range .Services}}
	{{/* Resolve package alias for service registration */}}
	{{.GoPackageNameToken}}.Register{{.GoName}}Server(grpcServer, New{{.GoName}}MockServer())
	{{end}}

	log.Printf("grpcmock: gRPC server starting on :%s", grpcPort)
	go func() {
		if err := grpcServer.Serve(lis); err != nil {
			log.Fatalf("grpcmock: failed to serve gRPC: %v", err)
		}
	}()
	defer grpcServer.GracefulStop() // Ensure gRPC server is stopped on shutdown

	// Start HTTP server using the runtime's helper
	// Pass nil for httpMux to use the default one with /expectations and /verifications
	_, httpShutdown := runtime.StartHTTPServer(httpPort, nil)
	defer httpShutdown()


	log.Println("grpcmock: Servers started. Press Ctrl+C to exit.")
	runtime.ListenForShutdownSignal(grpcServer.GracefulStop, httpShutdown)
	log.Println("grpcmock: All servers shut down.")
}

func main() {
	grpcPort := "{{.GRPCPort}}" // Default, can be overridden by flags or env vars
	httpPort := "{{.HTTPPort}}" // Default, can be overridden by flags or env vars

	if p := os.Getenv("GRPCMOCK_GRPC_PORT"); p != "" {
 		grpcPort = p
	}
	if p := os.Getenv("GRPCMOCK_HTTP_PORT"); p != "" {
		httpPort = p
	}
	flag.StringVar(&grpcPort, "grpc-port", grpcPort, "gRPC server port")
	flag.StringVar(&httpPort, "http-port", httpPort, "HTTP control server port")
	flag.Parse()

	StartMockServer(grpcPort, httpPort)
}