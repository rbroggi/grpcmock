// Code generated by protoc-gen-grpcmock. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"flag" 
	"fmt"
	"log"
	"net"
	"os" 
	"errors"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status" 
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto" 

	"github.com/rbroggi/grpcmock/protoc-gen-grpcmock/runtime"
)

{{range .Services}}
// {{.GoName}}MockServer is the mock server for the {{.GoName}} service.
type {{.GoName}}MockServer struct {
	{{.QualifiedUnimplementedServerType}} // Use the fully qualified type
}

// New{{.GoName}}MockServer creates a new mock server.
func New{{.GoName}}MockServer() *{{.GoName}}MockServer {
	return &{{.GoName}}MockServer{}
}

{{$service := .}} 
{{range .Methods}} 
func (s *{{$service.GoName}}MockServer) {{.GoName}}(
	{{if .ClientStreaming}}
	stream {{.QualifiedStreamServerType}},
	{{else if .ServerStreaming}}
	req *{{.InputType}}, stream {{.QualifiedStreamServerType}},
	{{else}} // Unary
	ctx context.Context, req *{{.InputType}},
	{{end}}
) {{if .ServerStreaming}} (error) {{else if .ClientStreaming}} (error) {{else}} (*{{.OutputType}}, error) {{end}} { // .OutputType is already fully qualified
	
	fullMethod := "{{.FullMethodName}}"
	log.Printf("grpcmock: Received call to %s", fullMethod)

	var currentReqProto proto.Message
	var incomingMD metadata.MD
	var err error 
	
	{{if .ClientStreaming}}
	firstReqProto, errRecv := stream.Recv()
	if errRecv == io.EOF {
		log.Printf("grpcmock: Client stream for %s ended before any message for matching.", fullMethod)
		currentReqProto = nil 
	} else if errRecv != nil {
		log.Printf("grpcmock: Error receiving from client stream for %s: %v", fullMethod, errRecv)
		return status.Errorf(codes.Internal, "error receiving from client stream: %v", errRecv)
	} else {
		currentReqProto = firstReqProto // Assign the received proto.Message
	}
	incomingMD, _ = metadata.FromIncomingContext(stream.Context())
	{{else if .ServerStreaming}}
	currentReqProto = req 
	incomingMD, _ = metadata.FromIncomingContext(stream.Context())
	{{else}} // Unary
	currentReqProto = req
	incomingMD, _ = metadata.FromIncomingContext(ctx)
	{{end}}

	runtime.RecordCall(fullMethod, incomingMD, currentReqProto)
	
	expectation := runtime.FindMatchingExpectation(fullMethod, incomingMD, currentReqProto)

	if expectation == nil {
		err = status.Errorf(codes.Unimplemented, "no matching expectation for %s", fullMethod)
		{{if or .ServerStreaming .ClientStreaming}} return err {{else}} return nil, err {{end}}
	}

	if len(expectation.Response.Headers) > 0 {
		outgoingMD := metadata.New(expectation.Response.Headers)
		var headerErr error
		{{if .ClientStreaming}}
		headerErr = stream.SetHeader(outgoingMD)
		{{else if .ServerStreaming}}
		headerErr = stream.SendHeader(outgoingMD)
		{{else}} // Unary
		headerErr = grpc.SetHeader(ctx, outgoingMD)
		{{end}}
		if headerErr != nil {
			log.Printf("grpcmock: failed to set/send response header for %s: %v", fullMethod, headerErr)
			{{if or .ClientStreaming .ServerStreaming}} if headerErr != nil { return headerErr } {{end}}
		}
	}
	
	if expectation.Response.Error != nil {
		log.Printf("grpcmock: Returning error for %s: code=%v, msg=%s", fullMethod, expectation.Response.Error.Code, expectation.Response.Error.Message)
		err = status.Errorf(expectation.Response.Error.Code, expectation.Response.Error.Message)
		{{if or .ServerStreaming .ClientStreaming}} return err {{else}} return nil, err {{end}}
	}

	{{if .ServerStreaming}}
		resp := new({{.OutputType}}) // Create new instance of the qualified OutputType
		if errUnmarshal := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp); errUnmarshal != nil { 
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, errUnmarshal)
			return status.Errorf(codes.Internal, "failed to unmarshal mock server stream response: %v", errUnmarshal)
		}
		if errSend := stream.Send(resp); errSend != nil {
			log.Printf("grpcmock: Error sending server stream response for %s: %v", fullMethod, errSend)
			return errSend
		}
		return nil 
	{{else if .ClientStreaming}}
		for {
			// If firstReqProto was nil (EOF on first Recv), this loop won't execute meaningfully for subsequent Recv.
			// The primary Recv for matching is done above. This loop is to consume the rest.
			// If currentReqProto is already nil due to initial EOF, this loop might not be what's intended.
			// For simplicity, let's assume stream was open and first message was for matching.
			if currentReqProto == nil && firstReqProto == nil { // Stream was empty from start
                break
            }
			_, errLoop := stream.Recv() // Consume subsequent messages
			if errLoop == io.EOF { break }
			if errLoop != nil {
				log.Printf("grpcmock: Error receiving subsequent message from client stream for %s: %v", fullMethod, errLoop)
				return status.Errorf(codes.Internal, "error in client stream: %v", errLoop)
			}
		}
		resp := new({{.OutputType}}) // Create new instance
		if errUnmarshal := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp); errUnmarshal != nil {
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, errUnmarshal)
			return status.Errorf(codes.Internal, "failed to unmarshal mock client stream response: %v", errUnmarshal)
		}
		return stream.SendAndClose(resp)
	{{else}} // Unary
		resp := new({{.OutputType}}) // Create new instance of the qualified OutputType
		if errUnmarshal := runtime.DefaultUnmarshaler.Unmarshal(expectation.Response.Body, resp); errUnmarshal != nil {
			log.Printf("grpcmock: Failed to unmarshal mock response body for %s: %v", fullMethod, errUnmarshal)
			return nil, status.Errorf(codes.Internal, "failed to unmarshal mock unary response: %v", errUnmarshal)
		}
		return resp, nil
	{{end}}
}
{{end}} {{/* End range Methods */}}
{{end}} {{/* End range Services */}}

func StartMockServer(grpcPort, httpPort string) {
	lis, err := net.Listen("tcp", fmt.Sprintf(":%s", grpcPort))
	if err != nil {
		log.Fatalf("grpcmock: failed to listen on gRPC port %s: %v", grpcPort, err)
	}
	
	grpcServer := grpc.NewServer()
	
	{{range .Services}}
	// Use the pre-qualified function name for registration
	{{.QualifiedRegisterServerFuncName}}(grpcServer, New{{.GoName}}MockServer())
	{{end}}
	
	log.Printf("grpcmock: gRPC server starting on :%s", grpcPort)
	go func() {
		// Use errors.Is to prevent logging an error on graceful shutdown
		if serveErr := grpcServer.Serve(lis); serveErr != nil && !errors.Is(serveErr, grpc.ErrServerStopped) {
			log.Fatalf("grpcmock: failed to serve gRPC: %v", serveErr)
		}
	}()

	_, httpShutdown := runtime.StartHTTPServer(httpPort, nil)

	log.Println("grpcmock: Servers started. Press Ctrl+C to exit.")
	runtime.ListenForShutdownSignal(func() {
		log.Println("grpcmock: shutting down gRPC server...")
		grpcServer.GracefulStop()
		log.Println("grpcmock: gRPC server stopped.")
	}, httpShutdown) 
	log.Println("grpcmock: All servers shut down.")
}

func main() {
	var grpcPort, httpPort string 

	defaultGrpcPort := "{{.GRPCPort}}"
	defaultHttpPort := "{{.HTTPPort}}"

	envGRPCPort := os.Getenv("GRPCMOCK_GRPC_PORT")
	if envGRPCPort != "" {
 		defaultGrpcPort = envGRPCPort
	}
	envHTTPPort := os.Getenv("GRPCMOCK_HTTP_PORT")
	if envHTTPPort != "" {
		defaultHttpPort = envHTTPPort
	}

	flag.StringVar(&grpcPort, "grpc-port", defaultGrpcPort, "gRPC server port for the mock")
	flag.StringVar(&httpPort, "http-port", defaultHttpPort, "HTTP control server port for the mock")
	flag.Parse()

	StartMockServer(grpcPort, httpPort)
}
